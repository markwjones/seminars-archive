<!DOCTYPE html>
<html lang="en-GB">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<link href='http://fonts.googleapis.com/css?family=Lato:100,300,400' rel='stylesheet' type='text/css'>
<link href="../resources/compsci_seminar4.css" rel="stylesheet" type="text/css" media="all">
<link href="../resources/print.css" rel="stylesheet" type="text/css" media="print">
<link href="../resources/favicon.ico" rel="shortcut icon" type="image/x-icon">

<title>Computer Science Seminar</title>
</head>

<body>
<!-- Begin Top Logo -->
<div id="header">
  <a href="http://www.swansea.ac.uk/"><img src="../resources/icon.png" alt="Swansea University" title="Visit the Swansea University home page" /></a>
    <div><a href="http://www.swansea.ac.uk/compsci/">Computer Science</a></div>
</div>
<!-- End Top Logo -->

<div class="rightcol">

<h1>Model checking games</h1>
<h2>Erich Gr√§del</h2>
<p>Aachen</p>
<p>Model checking problems (\"is a given formula true in a given structure?\") for almost every logic can be cast as strategy problems (\"which player does have a winning strategy in a given game?\") for the appropriate evaluation games (also called Hintikka games). <br /><br />In games for first-order logic, all plays are finite and the strategy problem can be solved in linear time in the size of the game graph. For fixed point logics, the appropriate evaluation games are parity games, which admit also infinite plays. Each position is assigned a priority, and the winner of an infinite play is determined according to whether the least priority seen infinitely often during the play is even or odd. <br /><br />Infinite games are also important for other applications. They model in a natural way the non-terminating interaction of a reactive system with its environment: the specification of a reactive system can be seen as a winning condition in a game, and a reactive program that fulfills the specification implements a winning strategy. Parity games are especially interesting because on one side, they are powerful enough to simulate large classes of games and, on the other side they admit positional winning strategies. <br /><br />An polynomial time algorithm for computing winning sets and winning strategies of parity game would also provide a solution for the model checking problem for the modal mu-calculus, and vice versa. While we do not know whether this is possible in general, we can analyze the structure of parity games and isolate `easy' cases that admit efficient solutions. We link these `easy games' to logic and thus obtain efficient model checking algorithms for fragments of fixed point logic. </p>
<p><b>Thursday 08 May 2003</b></p>
<p><b>Robert Recorde Room, Department of Computer Science, Swansea</b></p>

  

  <!-- InstanceEndEditable -->

</div>


<div class="leftcol">
<!--<div class="menu">
  <p>SERIES</p>
  <ul>
  <li><a href="seminars?date=2010-09-01">Departmental Colloquia Archive</a></li>
  <li><a href="pcvseminars?date=today">Proof, Complexity, Verification</a></li>
  <li><a href="algseminars?date=2012-09-01">Algebraic Specification</a></li>
  <li><a href="deptseminars?date=2002-09-01">Departmental Seminar Archive</a></li>
  </ul>
</div>
-->
  	<div class="menu">
<ul>
	<li><a href="../years/1993-1994.html">1993-1994</a></li>
	<li><a href="../years/1994-1995.html">1994-1995</a></li>
	<li><a href="../years/1995-1996.html">1995-1996</a></li>
	<li><a href="../years/1996-1997.html">1996-1997</a></li>
	<li><a href="../years/1997-1998.html">1997-1998</a></li>
	<li><a href="../years/1998-1999.html">1998-1999</a></li>
	<li><a href="../years/1999-2000.html">1999-2000</a></li>
	<li><a href="../years/2000-2001.html">2000-2001</a></li>
	<li><a href="../years/2001-2002.html">2001-2002</a></li>
	<li><a href="../years/2002-2003.html">2002-2003</a></li>
	<li><a href="../years/2003-2004.html">2003-2004</a></li>
	<li><a href="../years/2004-2005.html">2004-2005</a></li>
	<li><a href="../years/2005-2006.html">2005-2006</a></li>
	<li><a href="../years/2006-2007.html">2006-2007</a></li>
	<li><a href="../years/2007-2008.html">2007-2008</a></li>
	<li><a href="../years/2008-2009.html">2008-2009</a></li>
	<li><a href="../years/2009-2010.html">2009-2010</a></li>
	<li><a href="../years/2010-2011.html">2010-2011</a></li>
	<li><a href="../years/2011-2012.html">2011-2012</a></li>
	<li><a href="../years/2012-2013.html">2012-2013</a></li>
	<li><a href="../years/2013-2014.html">2013-2014</a></li>
	<li><a href="../years/2014-2015.html">2014-2015</a></li>
	<li><a href="../years/2015-2016.html">2015-2016</a></li>
	<li><a href="../years/2016-2017.html">2016-2017</a></li>
</ul>

	</div>

  
</div>

</body>
<!-- InstanceEnd --></html>